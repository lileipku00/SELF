!
!////////////////////////////////////////////////////////////////////////
!
!      SimpleExtrusion.f90
!      Created: March 28, 2013 9:55 AM 
!      By: David Kopriva  
!
!     Take a quad mesh generated by the SpecMesh2D code and
!     extrude it vertically in the "z" direction to create a
!     3D Hex mesh or rotate it about the x-axis to generate
!     a volume of revolution.
!
!////////////////////////////////////////////////////////////////////////
!
      Module SimpleSweepModule
      USE FTValueDictionaryClass
      USE SMConstants
      USE ProgramGlobals
      USE FTExceptionClass
      USE ReaderExceptions
      USE SharedExceptionManagerModule
      USE HexMeshObjectsModule
      IMPLICIT NONE 
! 
!--------------------------------------------------------------- 
! Define methods to generate a 3D mesh from a 2D one by straight
! line extrusion or simple rotation
!---------------------------------------------------------------
! 
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_EXTRUSION_ALGORITHM_KEY    = "SimpleExtrusion"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_ROTATION_ALGORITHM_KEY     = "SimpleRotation"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_EXTRUSION_HEIGHT_KEY       = "ExtrusionHeight"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_SWEEP_SUBDIVISIONS_KEY     = "ExtrusionSubdivisions"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_SWEEP_STARTNAME_KEY        = "ExtrusionStartName"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_SWEEP_ENDNAME_KEY          = "ExtrusionEndName"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_SWEEP_DIRECTION_KEY        = "ExtrusionDirectionName"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_ROTATION_ANGLE_KEY         = "RotationAngleName"
      CHARACTER(LEN=STRING_CONSTANT_LENGTH), PARAMETER :: SIMPLE_SWEEP_PERIODIC_KEY         = "isPeriodicName"
      
      INTEGER, PARAMETER :: SWEEP_FLOOR = 1, SWEEP_CEILING = 2
!

      REAL(KIND=RP), ALLOCATABLE :: chebyPoints(:)
!
!     ------------------------------------------------------------
!     Given the global node ID, get the level and 2D node location
!     in the nodes array
!     ------------------------------------------------------------
!
      INTEGER, ALLOCATABLE :: locAndLevelForNodeID(:,:)
      
!     ========      
      CONTAINS 
!     ========      
!
!////////////////////////////////////////////////////////////////////////
!
      SUBROUTINE ReadSimpleExtrusionBlock( fUnit, dict ) 
!
!        Example block is:
!
!            \begin{SimpleExtrusion}
!               direction          = 1 = x, 2 = y, 3 = z
!               height             = 10.0
!               subdivisions       = 5
!               start surface name = "bottom"
!               end surface name   = "top"
!            \end{SimpleExtrusion}
!
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         INTEGER                  :: fUnit
         CLASS(FTValueDictionary) :: dict
!
!        ---------------
!        Local variables
!        ---------------
!
         INTEGER                                :: ios
         INTEGER                                :: direction
         REAL(KIND=RP)                          :: height
         INTEGER                                :: subdivisions
         CHARACTER(LEN=LINE_LENGTH)             :: inputLine = " ", nameString
         INTEGER      , EXTERNAL                :: GetIntValue
         REAL(KIND=RP), EXTERNAL                :: GetRealValue
         CHARACTER( LEN=LINE_LENGTH ), EXTERNAL :: GetStringValue
         CLASS(FTException), POINTER            :: exception
!
!        ---------
!        Direction
!        ---------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            direction = GetIntValue(inputLine)
            CALL dict % addValueForKey(direction,SIMPLE_SWEEP_DIRECTION_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                         "direction", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ------
!        Height
!        ------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            height = GetRealValue( inputLine )
            CALL dict % addValueForKey(height,SIMPLE_EXTRUSION_HEIGHT_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                        "height", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ------------
!        Subdivisions
!        ------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            subdivisions = GetIntValue( inputLine )
            CALL dict % addValueForKey(subdivisions,SIMPLE_SWEEP_SUBDIVISIONS_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                        "subdivisions", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        -------------------
!        Bottom surface name
!        -------------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            nameString = GetStringValue( inputLine )
            CALL dict % addValueForKey(nameString,SIMPLE_SWEEP_STARTNAME_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                        "start surface name", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ----------------
!        Top surface name
!        ----------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            nameString = GetStringValue( inputLine )
            CALL dict % addValueForKey(nameString,SIMPLE_SWEEP_ENDNAME_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                       "end surface name", "ReadSimpleExtrusionBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 

      END SUBROUTINE ReadSimpleExtrusionBlock
!
!////////////////////////////////////////////////////////////////////////
!
      SUBROUTINE ReadSimpleRotationBlock( fUnit, dict ) 
!
!        Example block is:
!
!            \begin{SimpleRotation}
!               direction               = 1 = x, 2 = y, 3 = z
!               rotation angle factor   = 0.5
!               subdivisions            = 5
!               start surface name      = "bottom"
!               end surface name        = "top"
!            \end{SimpleExtrusion}
!
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         INTEGER                  :: fUnit
         CLASS(FTValueDictionary) :: dict
!
!        ---------------
!        Local variables
!        ---------------
!
         INTEGER                                :: ios
         INTEGER                                :: direction
         INTEGER                                :: subdivisions
         REAL(KIND=RP)                          :: angleFactor
         CHARACTER(LEN=LINE_LENGTH)             :: inputLine = " ", nameString
         INTEGER      , EXTERNAL                :: GetIntValue
         REAL(KIND=RP), EXTERNAL                :: GetRealValue
         CHARACTER( LEN=LINE_LENGTH ), EXTERNAL :: GetStringValue
         CLASS(FTException), POINTER            :: exception
!
!        ---------
!        Direction
!        ---------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            direction = GetIntValue(inputLine)
            CALL dict % addValueForKey(direction,SIMPLE_SWEEP_DIRECTION_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                         "direction", "ReadSimpleRotationBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ----------------------
!        Angle (Fraction of PI)
!        ----------------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            angleFactor = GetRealValue( inputLine )
            CALL dict % addValueForKey(angleFactor,SIMPLE_ROTATION_ANGLE_KEY)
         ELSE 
            exception => ReaderException("Simple rotation read error", "Error reading variable", &
                                         "rotation angle", "ReadSimpleRotationBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ------------
!        Subdivisions
!        ------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            subdivisions = GetIntValue( inputLine )
            CALL dict % addValueForKey(subdivisions,SIMPLE_SWEEP_SUBDIVISIONS_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                         "subdivisions", "ReadSimpleRotationBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        -------------------
!        Bottom surface name
!        -------------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            nameString = GetStringValue( inputLine )
            CALL dict % addValueForKey(nameString,SIMPLE_SWEEP_STARTNAME_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                         "start surface name", "ReadSimpleRotationBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 
!
!        ----------------
!        Top surface name
!        ----------------
!
         READ ( fUnit, FMT = '(a132)', IOSTAT = ios ) inputLine
         IF ( ios == 0 )     THEN
            nameString = GetStringValue( inputLine )
            CALL dict % addValueForKey(nameString,SIMPLE_SWEEP_ENDNAME_KEY)
         ELSE 
            exception => ReaderException("Simple extrusion read error", "Error reading variable", &
                                         "end surface name", "ReadSimpleRotationBlock")
            CALL throw(exception)
            CALL exception % release()
            RETURN
         END IF 

      END SUBROUTINE ReadSimpleRotationBlock
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE PerformSimpleMeshSweep( project, hex8Mesh, parametersDictionary, algorithmChoice )
         USE MeshProjectClass  
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         TYPE ( MeshProject )        :: project
         TYPE ( StructuredHexMesh )  :: hex8Mesh
         CLASS( FTValueDictionary )  :: parametersDictionary
!
!        ---------------
!        Local Variables
!        ---------------
!
         CLASS(SMMesh), POINTER :: quadMesh
         
         INTEGER                :: numberOfLayers
         INTEGER                :: numberOf2DNodes, numberOfQuadElements
         INTEGER                :: numberOfNodes
         INTEGER                :: numberOfBoundaryFaces
         INTEGER                :: node2DID
         INTEGER                :: N, pMutation
         INTEGER                :: algorithmChoice
         
         
         TYPE(SMNodePtr)   , DIMENSION(:), ALLOCATABLE :: quadMeshNodes
         CLASS(SMNode)                   , POINTER     :: currentNode
         CLASS(FTObject)                 , POINTER     :: obj
         
         INTEGER                     :: rotMap(3) = [3, 3, 1]
!                  
!
         quadMesh              => project % mesh
         numberOfBoundaryFaces = 0
         N                     =  project % runParams % polynomialOrder
!
!        -----------------------------------------------------------------
!        Rotate the mesh for extrusion/rotation in the requested direction
!        -----------------------------------------------------------------
!
         pMutation = parametersDictionary % integerValueForKey(SIMPLE_SWEEP_DIRECTION_KEY)
         
         IF ( algorithmChoice == SIMPLE_EXTRUSION_ALGORITHM )     THEN
            IF ( pMutation < 3 )     THEN
               CALL quadMesh % permuteMeshDirection(pmutation)
            END IF 
         ELSE 
!
!           -------------------------------------------------------------------------
!           Rotation about the z axis requires the 2D mesh to be in a different plane
!           -------------------------------------------------------------------------
!
            IF ( rotMap(pMutation) < 3 )     THEN
               CALL quadMesh % permuteMeshDirection(rotMap(pMutation))
            END IF 
         END IF 
!
!        ---------------------------------------------------------------
!        Make sure that the nodes and elements are consecutively ordered
!        and that the edges refer to the correct elements.
!        ---------------------------------------------------------------
!
         CALL quadMesh % renumberObjects(NODES)
         CALL quadMesh % renumberObjects(ELEMENTS)
         CALL quadMesh % renumberObjects(EDGES)
         numberOfQuadElements = quadMesh % elements % count()
!
!        ---------------------------------------------------------------------
!        Allocate memory for the hex mesh. Since the extrusion is 
!        structured in the new direction, the data structures can be accessed
!        as arrays. We also know exactly how many nodes and elements are to be
!        created, so we don't need pointers for most things.
!        ---------------------------------------------------------------------
!
         numberOfLayers = parametersDictionary % integerValueForKey( SIMPLE_SWEEP_SUBDIVISIONS_KEY )
         CALL InitializeStructuredHexMeshFromQuadMesh( hex8Mesh, quadMesh, numberOfLayers )
!
!        ---------------------------------------
!        Gather nodes for easy access
!        TODO: The list class now has a function
!        to return an array of the objects.
!        ---------------------------------------
!
         numberOf2DNodes = quadMesh % nodes % count()
         numberOfNodes   = numberOf2DNodes*(numberOfLayers + 1)
         ALLOCATE( quadMeshNodes(numberOf2DNodes) )
         
         CALL quadMesh % nodesIterator % setToStart()
         DO WHILE( .NOT.quadMesh % nodesIterator % isAtEnd())
         
            obj => quadMesh % nodesIterator % object()
            CALL castToSMNode(obj,currentNode)
            node2DID = currentNode % id
            quadMeshNodes(node2DID) % node => currentNode
         
            CALL quadMesh % nodesIterator % moveToNext() 
         END DO 
!
!        ---------------------------------------------------------------
!        Allocate connections between global ID and local (2D, level) id
!        ---------------------------------------------------------------
!
         ALLOCATE( locAndLevelForNodeID(2, numberOfNodes))
!
!        ------------------------------------------------
!        Do the sweeping. These procedures must be called
!        in order.
!        ------------------------------------------------
!
         CALL sweepNodes( quadMeshNodes, hex8Mesh, algorithmChoice, parametersDictionary )
         CALL sweepElements( quadMesh, hex8Mesh, numberofLayers, algorithmChoice, parametersDictionary )
         CALL constructSweptFaces( project, quadMesh, hex8Mesh, N, algorithmChoice, parametersDictionary )
         CALL constructCapFaces( hex8Mesh, numberOfQuadElements, numberOfLayers )
         CALL interpolateCapFaces(hex8Mesh , N )
!

      END SUBROUTINE PerformSimpleMeshSweep
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE sweepNodes( quadMeshNodes, hex8Mesh, algorithmChoice, parametersDictionary )
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         TYPE ( StructuredHexMesh )    :: hex8Mesh
         TYPE( FTValueDictionary)      :: parametersDictionary
         TYPE(SMNodePtr), DIMENSION(:) :: quadMeshNodes
         INTEGER                       :: algorithmChoice
!
!        ---------------
!        Local Variables
!        ---------------
!
         INTEGER                           :: numberOf2DNodes
         INTEGER                           :: nodeID
         INTEGER                           :: j, k
         INTEGER                           :: pMutation
         INTEGER                           :: numberOfLayers
         
         REAL(KIND=RP)                     :: h, dz, dTheta, theta
!
         numberOf2DNodes = SIZE(quadMeshNodes)
         pMutation       = parametersDictionary % integerValueForKey(SIMPLE_SWEEP_DIRECTION_KEY)
!
!        ---------------------------------------
!        Generate the new nodes for the hex mesh
!        layer by layer. Order the new node IDs
!        layer by layer, too.
!        ---------------------------------------
!
         IF ( algorithmChoice == SIMPLE_EXTRUSION_ALGORITHM )     THEN
            numberOfLayers = parametersDictionary % integerValueForKey( SIMPLE_SWEEP_SUBDIVISIONS_KEY )
            h              = parametersDictionary % doublePrecisionValueForKey( SIMPLE_EXTRUSION_HEIGHT_KEY )
            dz             = h/numberofLayers
             
            nodeID = 1
            DO j = 0, numberofLayers
               DO k = 1, numberOf2DNodes
                  hex8Mesh % nodes(k,j) % globalID = nodeID
                  hex8Mesh % nodes(k,j) % x  = extrudedNodeLocation(baseLocation = quadMeshNodes(k) % node % x, &
                                                                    delta = j*dz, pmutation = pMutation)
                  locAndLevelForNodeID(1,nodeID) = k
                  locAndLevelForNodeID(2,nodeID) = j
                  nodeID = nodeID + 1
               END DO   
            END DO
            
         ELSE
         
            numberOfLayers = parametersDictionary % integerValueForKey( SIMPLE_SWEEP_SUBDIVISIONS_KEY )
            theta          = PI * parametersDictionary % doublePrecisionValueForKey( SIMPLE_ROTATION_ANGLE_KEY )
            dTheta         = theta/numberofLayers
             
            nodeID = 1
            DO j = 0, numberofLayers
               DO k = 1, numberOf2DNodes
                  hex8Mesh % nodes(k,j) % globalID = nodeID
                  hex8Mesh % nodes(k,j) % x  = rotatedNodeLocation(baseLocation = quadMeshNodes(k) % node % x, &
                                                                   theta        = j*dTheta, &
                                                                   pmutation    = pMutation) 
                  locAndLevelForNodeID(1,nodeID) = k
                  locAndLevelForNodeID(2,nodeID) = j
                  nodeID = nodeID + 1
               END DO   
            END DO
            
         END IF 
!
      END SUBROUTINE sweepNodes
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE sweepElements( quadMesh, hex8Mesh, numberofLayers, algorithmChoice, parametersDictionary )
!
!        -------------------------------
!        Call after generating the nodes
!        -------------------------------
!
         USE MeshProjectClass  
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         TYPE ( SMMesh )             :: quadMesh
         TYPE ( StructuredHexMesh )  :: hex8Mesh
         INTEGER                     :: numberOfLayers
         TYPE( FTValueDictionary)    :: parametersDictionary
         INTEGER                     :: algorithmChoice
!
!        ---------------
!        Local Variables
!        ---------------
!
         INTEGER                           :: numberOfQuadElements
         INTEGER                           :: elementID, nodeID, node2DID, quadElementID
         INTEGER                           :: j, k
         INTEGER                           :: pMutation
         
         
         CLASS(SMNode)                   , POINTER     :: node
         CLASS(SMElement)                , POINTER     :: currentQuadElement
         CLASS(FTObject)                 , POINTER     :: obj
         
         numberOfQuadElements = quadMesh % elements % count()
         pMutation            = parametersDictionary % integerValueForKey(SIMPLE_SWEEP_DIRECTION_KEY)
!
!        ---------------------------------
!        Build the elements layer by layer
!        ---------------------------------
!
         elementID = 1
         DO j = 1, numberOfLayers
            quadElementID = 1
            
            CALL quadMesh % elementsIterator % setToStart()
            
            DO WHILE( .NOT. quadMesh % elementsIterator % isAtEnd() )
               obj => quadMesh % elementsIterator % object()
               CALL castToSMElement(obj,currentQuadElement)
!
!              -----------------------
!              Set the element nodeIDs
!              -----------------------
!
               DO k = 1, 4
!
!                 -------------
!                 Bottom of hex
!                 -------------
!
                  obj => currentQuadElement % nodes % objectAtIndex(k)
                  CALL cast(obj,node)
                  node2DID = node % id
                  nodeID   = hex8Mesh % nodes(node2DID,j-1) % globalID
                  hex8Mesh % elements(quadElementID,j) % nodeIDs(k) = nodeID
!
!                 ----------
!                 Top of hex
!                 ----------
!
                  nodeID = hex8Mesh % nodes(node2DID,j) % globalID
                  hex8Mesh % elements(quadElementID,j)  % nodeIDs(k+4) = nodeID
                  
               END DO
               
               hex8Mesh % elements(quadElementID,j) % faceID    = NONE
               hex8Mesh % elements(quadElementID,j) % globalID  = elementID
               hex8Mesh % elements(quadElementID,j) % bFaceFlag = OFF
               hex8Mesh % elements(quadElementID,j) % bFaceName = NO_BC_STRING
!
!              ------------------------------------------------------------------
!              Set boundary condition names at the start and end of the extrusion
!              as defined in the control file
!              ------------------------------------------------------------------
!
               IF ( j == 1 )     THEN
                  hex8Mesh % elements(quadElementID,j) % bFaceName(3) = &
                  parametersDictionary % stringValueForKey(key             = SIMPLE_SWEEP_STARTNAME_KEY,&
                                                           requestedLength = LINE_LENGTH)
               ELSE IF (j == numberOfLayers)     THEN 
                  hex8Mesh % elements(quadElementID,j) % bFaceName(5) = &
                  parametersDictionary % stringValueForKey(key             = SIMPLE_SWEEP_ENDNAME_KEY,&
                                                           requestedLength = LINE_LENGTH)
               END IF 
               
               quadElementID                                 = quadElementID + 1
               elementID                                     = elementID + 1
               
               CALL quadMesh % elementsIterator % moveToNext()
            END DO 
            
         END DO 
!
      END SUBROUTINE sweepElements
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE constructSweptFaces( project, quadMesh, hex8Mesh, N, &
                                      algorithmChoice, parametersDictionary )
!
!        ----------------------------------------------------------
!        These faces are created by sweeping the quad element edges
!        It must be called after the hex elements are swept.
!        ----------------------------------------------------------
!
         USE MeshProjectClass
         IMPLICIT NONE  
!
!        ---------
!        Arguments
!        ---------
!
         TYPE ( MeshProject )        :: project
         TYPE ( StructuredHexMesh )  :: hex8Mesh
         TYPE ( SMMesh )             :: quadMesh
         TYPE ( FTValueDictionary)   :: parametersDictionary
         INTEGER                     :: numberOfLayers, N, algorithmChoice
!
!        ---------------
!        Local variables
!        ---------------
!
         INTEGER                     :: numberOfBoundaryFaces
         INTEGER                     :: faceID, quadElementIDL, quadElementIDR
         INTEGER                     :: j, k, l
         INTEGER                     :: eIdLeft, eIDRight, edgeSideL, edgeSideR
         INTEGER                     :: faceNumberL, faceNumberR
         INTEGER                     :: pMutation
         INTEGER                     :: nodeID1, nodeID2
         
         REAL(KIND=RP)               :: x(3), xTmp(3), x1(3), x2(3)
         REAL(KIND=RP)               :: dz, dTheta, h, theta
         
         CLASS(SMElement)                , POINTER     :: e
         CLASS(SMEdge)                   , POINTER     :: currentEdge
         CLASS(FTObject)                 , POINTER     :: obj
         
         CLASS(SMNode)        , POINTER :: node1, node2
         CLASS(SMCurve)       , POINTER :: c
         CLASS(SMChainedCurve), POINTER :: chain
         
         REAL(KIND=RP)               :: tStart, tEnd, t_k, deltaT
         INTEGER                     :: curveId
         CHARACTER(LEN=32)           :: noCurveName(-4:-1) = (/"Right", "Left ", "Front", "Back " /)
         INTEGER                     :: rotMap(3) = [3, 3, 1]
!
!        -----------------------------------------------------------------------------
!        dir stores the relative direction of one quad element edge to its neighbor
!        e.g. Side 2 (left) associates with side 1 (right) then the index on the slave
!        runs in the opposite direction. Therefore, dir(2,1) = -1
!        -----------------------------------------------------------------------------
!
         INTEGER, DIMENSION(4,4)  :: dir = RESHAPE((/-1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,-1/),(/4,4/))
!        
         pMutation = parametersDictionary % integerValueForKey(SIMPLE_SWEEP_DIRECTION_KEY)
         
         numberOfLayers = parametersDictionary % integerValueForKey( SIMPLE_SWEEP_SUBDIVISIONS_KEY )
         IF ( algorithmChoice == SIMPLE_EXTRUSION_ALGORITHM )     THEN
            h              = parametersDictionary % doublePrecisionValueForKey( SIMPLE_EXTRUSION_HEIGHT_KEY )
            dz             = h/numberofLayers
         ELSE
            theta          = PI * parametersDictionary % doublePrecisionValueForKey( SIMPLE_ROTATION_ANGLE_KEY )
            dTheta         = theta/numberofLayers
         END IF 
!
!        ------------------------------------------------
!        For each layer, sweep each edge to create a face
!        ------------------------------------------------
!
         DO j = 1, numberOfLayers
            faceID = 1
            
            CALL quadMesh % edgesIterator % setToStart()
            
            DO WHILE( .NOT. quadMesh % edgesIterator % isAtEnd() )
               obj => quadMesh % edgesIterator % object()
               CALL cast(obj, currentEdge)
               
               hex8Mesh % faces(faceID,j) % levelID = faceID
               hex8Mesh % faces(faceID,j) % edge    => currentEdge
               CALL currentEdge % retain()
!
!              --------------------
!              Set the left element
!              --------------------
!
               e              => currentEdge % elements(1) % element
               quadElementIDL = e % id
               eIdLeft        = hex8Mesh % elements(quadElementIDL,j) % globalID
               edgeSideL      = currentEdge % elementSide(1)
               
               hex8Mesh % faces(faceID,j) % elementIDs(1) = eIdLeft
               faceNumberL                                = hexFaceForQuadEdge(edgeSideL)
               hex8Mesh % faces(faceID,j) % faceNumber(1) = faceNumberL
!
!              -------------------------
!              Refer back to the element
!              -------------------------
!
               hex8Mesh % elements(quadElementIDL,j) % faceID(faceNumberL) = faceID
!
!              -------------
!              Add the nodes
!              -------------
!
               DO k = 1, 4
                  hex8Mesh % faces(faceID,j) % nodeIDs(k) = &
                  hex8Mesh % elements(quadElementIDL,j) % nodeIDs(localFaceNode(k,hex8Mesh % faces(faceID,j) % faceNumber(1)))
               END DO  
!
!              ---------------------
!              Set the right element
!              ---------------------
!
               e  => currentEdge % elements(2) % element
               IF ( ASSOCIATED( e ) )     THEN
                  quadElementIDR = e % id
                  eIdRight      = hex8Mesh % elements(quadElementIDR,j) % globalID
                  edgeSideR     = currentEdge % elementSide(2)
                  faceNumberR   = hexFaceForQuadEdge(edgeSideR)
                 
                  hex8Mesh % faces(faceID,j) % elementIDs(2) = eIdRight
                  hex8Mesh % faces(faceID,j) % faceNumber(2) = faceNumberR
                  hex8Mesh % faces(faceID,j) % inc           = [dir(edgeSideL,edgeSideR),1]
                  
                  hex8Mesh % elements(quadElementIDR,j) % faceID(faceNumberR) = faceID

               ELSE
                  hex8Mesh % faces(faceID,j) % elementIDs(2) = NONE
                  hex8Mesh % faces(faceID,j) % faceNumber(2) = NONE
                  hex8Mesh % faces(faceID,j) % inc           = 0
               END IF
!
!              ----------------------------------
!              Generate boundary face information
!              ----------------------------------
!
               IF ( .NOT.ASSOCIATED(e) )     THEN ! This is a boundary face
                  numberOfBoundaryFaces = numberOfBoundaryFaces + 1
                  node1 => currentEdge % nodes(1) % node
                  node2 => currentEdge % nodes(2) % node
!
!                 ---------------------------------------------------------------------------
!                 See if this edge is on a boundary. One of the two nodes should be
!                 a ROW_SIDE, and that one is on a curve rather than the joint of two curves.
!                 The edge could be on an outer box, in which case it is a straight line, but
!                 still needs boundary name information
!                 ---------------------------------------------------------------------------
!
                  IF( IsOnBoundaryCurve(node1) .AND. IsOnBoundaryCurve(node2) )     THEN
!
!                    -----------------------------------------------------------
!                    Mark as on a boundary curve needing interpolant information
!                    -----------------------------------------------------------
!
                     hex8Mesh % elements(quadElementIDL,j) % bFaceFlag(faceNumberL) = ON
                     
                     IF( node1 % nodeType == ROW_SIDE )     THEN
                        curveID = node1 % bCurveID
                        c => project % model % curveWithID(curveId, chain)
                     ELSE IF( node2 % nodeType == ROW_SIDE )     THEN 
                        curveID = node2 % bCurveID
                        c => project % model % curveWithID(curveId, chain)
                     END IF
                     
                     hex8Mesh % elements(quadElementIDL,j) % bFaceName(faceNumberL) = c % curveName()
                     tStart = node1 % gWhereOnBoundary
                     tEnd   = node2 % gWhereOnBoundary
!
!                    ------------------------------
!                    Compute the interpolant points
!                    ------------------------------
!
                     deltaT = tEnd - tStart
                     IF( deltaT > maxParameterChange )     THEN !Crossing over the start
                        deltaT = deltaT - 1.0_RP
                     ELSE IF (deltaT < -maxParameterChange ) THEN
                        deltaT = 1.0_RP + deltaT
                     END IF
                    
                     ALLOCATE(hex8Mesh % faces(faceID,j) % x(3,0:N,0:N))
                     DO k = 0, N 
                    
                        t_k = tStart + deltaT*(1.0_RP - COS(k*PI/N))/2.0_RP
                        IF( t_k > 1.0_RP )     THEN
                           t_k = t_k - 1.0_RP
                        ELSE IF( t_k < 0.0_RP )     THEN
                           t_k = t_k + 1.0_RP
                        END IF
                        
                        x = chain % positionAt(t_k)
                        DO l = 0, N
                           IF ( algorithmChoice == SIMPLE_EXTRUSION_ALGORITHM )     THEN
                              t_k =  (j-1)*dz + dz*(1.0_RP - COS(l*PI/N))/2.0_RP
                              xTmp = [x(1),x(2),0.0_RP]
                              IF(pMutation<3) xTmp = CSHIFT(xTmp, SHIFT = -pmutation)
                              hex8Mesh % faces(faceID,j) % x(:,k,l) = extrudedNodeLocation(xTmp,t_k,pmutation)
                           ELSE 
                              t_k =  (j-1)*dTheta + dTheta*(1.0_RP - COS(l*PI/N))/2.0_RP
                              xTmp = [x(1),x(2),0.0_RP]
!                              IF(rotmap(pMutation)<3) xTmp = CSHIFT(xTmp, SHIFT = -rotMap(pmutation))
                              hex8Mesh % faces(faceID,j) % x(:,k,l) = rotatedNodeLocation(xTmp,t_k,pmutation)
                           END IF 
                        END DO  
                        
                      END DO

                  ELSE IF ( IsOnOuterBox(node1) .AND. IsOnOuterBox(node2) )     THEN
!
!                    --------------------------------------------------------------
!                    Only mark the boundary names for output, no interpolant needed
!                    --------------------------------------------------------------
!
                     IF( node1 % nodeType == CORNER_NODE )     THEN
                        hex8Mesh % elements(quadElementIDL,j) % bFaceName(faceNumberL) = noCurveName(node2 % bCurveID)
                     ELSE
                        hex8Mesh % elements(quadElementIDL,j) % bFaceName(faceNumberL) = noCurveName(node1 % bCurveID)
                     END IF
                     
                  END IF
               ELSE
!
!              --------------------------------------------------------------------
!              For rotation sweeping, ALL the swept faces are curved, so turn those 
!              on, too. Since the face is not on a 
!              boundary curve, the edge that generates it will be a straight line 
!              connecting the two end nodes.
!              --------------------------------------------------------------------
!
                  IF ( algorithmChoice == SIMPLE_ROTATION_ALGORITHM )     THEN
                     hex8Mesh % elements(quadElementIDL,j) % bFaceFlag(faceNumberL) = ON
                     hex8Mesh % elements(quadElementIDR,j) % bFaceFlag(faceNumberR) = ON
                     
                     nodeID1 = hex8Mesh % faces(faceID,j) % nodeIDs(1)
                     nodeID2 = hex8Mesh % faces(faceID,j) % nodeIDs(2)
                     x1      = hex8Mesh % nodes(locAndLevelForNodeID(1,nodeID1),locAndLevelForNodeID(2,nodeID1)) % x
                     x2      = hex8Mesh % nodes(locAndLevelForNodeID(1,nodeID2),locAndLevelForNodeID(2,nodeID2)) % x
                     
                     ALLOCATE(hex8Mesh % faces(faceID,j) % x(3,0:N,0:N))
                     
                     DO k = 0, N 
                    
                        t_k = (1.0_RP - COS(k*PI/N))/2.0_RP
                        x   = (1.0_RP - t_k)*x1 + t_k*x2 
                        DO l = 0, N
                           t_k =  (j-1)*dTheta + dTheta*(1.0_RP - COS(l*PI/N))/2.0_RP
                           xTmp = [x(1),x(2),0.0_RP]
                           hex8Mesh % faces(faceID,j) % x(:,k,l) = rotatedNodeLocation(xTmp,t_k,pMutation)
                        END DO  
                      END DO
                  END IF 
               END IF 
!              
               faceID = faceID + 1
               
               CALL quadMesh % edgesIterator % moveToNext()     
            END DO 
         END DO
         
      END SUBROUTINE constructSweptFaces
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE constructCapFaces( hex8Mesh, numberOfQuadElements, numberOfLayers )
!
!        ---------------------------------------------------------
!        Call constructCapFaces after the swept faces are computed
!        ---------------------------------------------------------
!
         USE MeshProjectClass  
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         INTEGER                     :: numberOfQuadElements
         TYPE ( StructuredHexMesh )  :: hex8Mesh
         INTEGER                     :: numberOfLayers
!
!        ---------------
!        Local Variables
!        ---------------
!
         INTEGER                    :: quadElementID
         INTEGER                    :: j, k
         INTEGER                    :: eIdLeft, eIDRight
!
!        ----------------------------
!        Construct the bottom and top 
!        faces from the layers
!        ----------------------------
!
         DO j = 0, numberOfLayers
            
            IF ( j == 0 )     THEN
            
               DO quadElementID = 1, numberOfQuadElements
!
!                 ----------------
!                 Interior element
!                 ----------------
!
                  eIdLeft    = hex8Mesh % elements(quadElementID,1) % globalID
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(1) = eIdLeft
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(1) = 3
                  
                  DO k = 1, 4
                     hex8Mesh % capFaces(quadElementID,j) % nodeIDs(k) = &
                           hex8Mesh % elements(quadElementID,1) % nodeIDs(localFaceNode(k,3))
                  END DO  
!
!                 -------------------
!                 No exterior element
!                 -------------------
!
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % inc           = 0
!                  
               END DO
               
            ELSE IF (j == numberOfLayers)     THEN
            
               DO quadElementID = 1, numberOfQuadElements
!
!                 ----------------
!                 Interior element
!                 ----------------
!
                  eIdLeft    = hex8Mesh % elements(quadElementID,numberOfLayers) % globalID
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(1) = eIdLeft
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(1) = 5
                  
                  DO k = 1, 4
                     hex8Mesh % capFaces(quadElementID,j) % nodeIDs(k) = &
                        hex8Mesh % elements(quadElementID,numberOfLayers) % nodeIDs(localFaceNode(k,5))
                  END DO  
!
!                 -------------------
!                 No exterior element
!                 -------------------
!
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(2) = NONE
                  hex8Mesh % capFaces(quadElementID,j) % inc           = 0
!                  
               END DO
               
            ELSE
            
               DO quadElementID = 1, numberOfQuadElements
!
!                 ----------------
!                 Interior element
!                 ----------------
!
                  eIdLeft = hex8Mesh % elements(quadElementID,j) % globalID
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(1) = eIdLeft
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(1) = 5
                  
                  DO k = 1, 4
                     hex8Mesh % capFaces(quadElementID,j) % nodeIDs(k) = &
                        hex8Mesh % elements(quadElementID,numberOfLayers) % nodeIDs(localFaceNode(k,5))
                  END DO  
!
!                 ----------------
!                 Exterior element
!                 ----------------
!
                  eIdRight = hex8Mesh % elements(quadElementID,j+1) % globalID
                  
                  hex8Mesh % capFaces(quadElementID,j) % elementIDs(2) = eIdRight
                  hex8Mesh % capFaces(quadElementID,j) % faceNumber(2) = 3
                  hex8Mesh % capFaces(quadElementID,j) % inc           = 1
!                  
               END DO
            END IF 

         END DO  
      END SUBROUTINE constructCapFaces
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE interpolateCapFaces( hex8Mesh, bCurveOrder)
!
!        --------------------------------------
!        Called after cap faces are constructed
!        --------------------------------------
!
         USE CurveInterpolantClass
         USE TransfiniteMapClass
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         INTEGER                   :: bCurveOrder
         TYPE( StructuredHexMesh ) :: hex8Mesh
!
!        ---------------
!        Local variables
!        ---------------
!
         INTEGER                                         :: numberOfLayers
         TYPE( CurveInterpolant ), DIMENSION(:), POINTER :: curves
         INTEGER                                         :: quadElementID, level
         INTEGER                                         :: j, k
         LOGICAL                                         :: hasCurve
         
         ALLOCATE(curves(4))
!
!        ------------------------------------------------------------
!        Distribute face points with a chebyshev Lobatto distribution
!        ------------------------------------------------------------
!
         ALLOCATE(chebyPoints(0:bCurveOrder))
         DO j = 0, bCurveOrder
            chebyPoints(j) = -COS(j*PI/bCurveOrder) 
         END DO  
         
         numberOfLayers = UBOUND(hex8Mesh % capFaces,2)
         
         DO quadElementID = 1, UBOUND( hex8Mesh % elements, 1 )
         
             DO level = 1, numberOfLayers
!
!              --------------------------------------------------------
!              We only have to compute the face point locations if the 
!              face is curved
!              --------------------------------------------------------
!
               hasCurve = .FALSE.
               DO k = 1, 4
                  IF( hex8Mesh % elements(quadElementID,level) % bFaceFlag( hexFaceForQuadEdge(k)) == ON )     THEN
                      hasCurve = .TRUE. 
                      EXIT
                  END IF 
               END DO 
               
               IF( .NOT. hasCurve ) CYCLE 
               
               hex8Mesh % elements(quadElementID,level) % bFaceFlag( 3 ) = ON
               hex8Mesh % elements(quadElementID,level) % bFaceFlag( 5 ) = ON  
!
!              --------------------------
!              Bottom face of the element
!              --------------------------
!
               CALL constructFaceCurvesForCapFace(hex8Mesh       = hex8Mesh, &
                                                  element        = hex8Mesh % elements(quadElementID,level), &
                                                  level          = level, &
                                                  curves         = curves, &
                                                  bCurveOrder    = bCurveOrder,&
                                                  floorOrCeiling = SWEEP_FLOOR)
                                                  
               CALL computeCapFacePoints(face        = hex8Mesh % capFaces(quadElementID,level-1), &
                                         bcurveOrder = bCurveOrder,&
                                         curves      = curves)
!
!              -------------------------
!              Top face for the last one
!              -------------------------
!
               IF (  level == numberOfLayers )     THEN
                  CALL constructFaceCurvesForCapFace(hex8Mesh       = hex8Mesh, &
                                                     element        = hex8Mesh % elements(quadElementID,level), &
                                                     level          = level, &
                                                     curves         = curves, &
                                                     bCurveOrder    = bCurveOrder,&
                                                     floorOrCeiling = SWEEP_CEILING)
                                                     
                  CALL computeCapFacePoints(face        = hex8Mesh % capFaces(quadElementID,level), &
                                            bcurveOrder = bCurveOrder,&
                                            curves      = curves)
               END IF 
               
            END DO  
         END DO 
         
         DO k = 1, 4
            CALL destruct(curves(k)) 
         END DO  
         DEALLOCATE(curves)
         
      END SUBROUTINE interpolateCapFaces
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE constructFaceCurveForElementFace(N, level, face, curve)
         USE CurveInterpolantClass
         IMPLICIT NONE  
!
!        ---------
!        Arguments
!        ---------
!
         INTEGER                     :: N
         INTEGER                     :: level
         TYPE( Face3D )              :: face
         TYPE( curveInterpolant )    :: curve
!
!        ---------------
!        Local variables
!        ---------------
!
         INTEGER                         :: j
         REAL(KIND=RP), DIMENSION(0:N,3) :: values
         
         DO j = 0, N
            values(j,:) = face % x(:,j,level) 
         END DO  
         
         CALL Construct(this   = curve      , &
                        N      = N          , &
                        nodes  = chebyPoints, &
                        values = values)

      END SUBROUTINE constructFaceCurveForElementFace
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE constructStraightLineCurve(N, startNode, endNode, curve)  
         USE CurveInterpolantClass
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         INTEGER :: N
         TYPE( Node3D )           :: startNode
         TYPE( Node3D )           :: endNode
         TYPE( CurveInterpolant ) :: curve
!
!        ---------------
!        Local variables
!        ---------------
!
         INTEGER                         :: j
         REAL(KIND=RP), DIMENSION(0:N,3) :: values
         
         DO j = 0, N
            values(j,:) = 0.5_RP*(1.0_RP - chebyPoints(j))*startNode % x + &
                          0.5_RP*(1.0_RP + chebyPoints(j))*endNode % x
        END DO  

         CALL Construct(this   = curve      , &
                        N      = N          , &
                        nodes  = chebyPoints, &
                        values = values)
         
      END SUBROUTINE constructStraightLineCurve
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE constructFaceCurvesForCapFace( hex8Mesh, element, level, &
                                                curves, bCurveOrder, floorOrCeiling )  
         USE CurveInterpolantClass
         IMPLICIT NONE
!
!        ---------
!        Arguments
!        ---------
!
         TYPE( StructuredHexMesh )                       :: hex8Mesh
         TYPE( Hex8Element )                             :: element
         TYPE( CurveInterpolant ), DIMENSION(:), POINTER :: curves
         INTEGER                                         :: bCurveOrder
         INTEGER                                         :: floorOrCeiling
!
!        ---------------
!        Local variables
!        ---------------
!
         INTEGER                  :: k
         TYPE( Node3D )           :: node1, node2
         INTEGER                  :: l
         
         INTEGER                  :: level
         INTEGER                  :: fID
         INTEGER                  :: nodeID1, nodeID2
         INTEGER                  :: localNodeID1, localNodeID2
         INTEGER, DIMENSION(2,4)  :: localNodeFaceMapBottom = RESHAPE(SOURCE = [1,2,2,3,4,3,1,4], SHAPE = [2,4])
         INTEGER, DIMENSION(2,4)  :: localNodeFaceMapTop    = RESHAPE(SOURCE = [5,6,6,7,8,7,5,8], SHAPE = [2,4])
!         
!
!        ---------------------------------------------------------
!        Grab the bottom or top row of the swept face as requested
!        ---------------------------------------------------------
!
         IF ( floorOrCeiling == SWEEP_FLOOR )     THEN
            l = 0
         ELSE
            l = bCurveOrder
         END IF
         
         
         
         DO k = 1, 4
            fID = element % faceID( hexFaceForQuadEdge(k) )
            
            IF( element % bFaceFlag( hexFaceForQuadEdge(k) ) == ON )     THEN
!
!              -----------------------------------
!              The curved sides on the bottom face
!              -----------------------------------
!
               CALL constructFaceCurveForElementFace(N           = bCurveOrder, &
                                                     level       = l      , &
                                                     face        = hex8Mesh % faces(fID, level), &
                                                     curve       = curves(k))
            ELSE 
!
!              ------------------
!              The straight sides
!              ------------------
!
               IF ( floorOrCeiling == SWEEP_FLOOR )     THEN
                  localNodeID1 = localNodeFaceMapBottom(1,k) ! Get the bottom nodes
                  localNodeID2 = localNodeFaceMapBottom(2,k)
               ELSE 
                  localNodeID1 = localNodeFaceMapTop(1,k) ! Get the bottom nodes
                  localNodeID2 = localNodeFaceMapTop(2,k)
               END IF 
               
               nodeID1      = element % nodeIDs(localNodeID1)
               nodeID2      = element % nodeIDs(localNodeID2)
               
               node1 = hex8Mesh % nodes(locAndLevelForNodeID(1,nodeID1), locAndLevelForNodeID(2,nodeID1))
               node2 = hex8Mesh % nodes(locAndLevelForNodeID(1,nodeID2), locAndLevelForNodeID(2,nodeID2))
               
               CALL constructStraightLineCurve(N         = bCurveOrder,&
                                               startNode = node1, &
                                               endNode   = node2, &
                                               curve     = curves(k))
            END IF 
         END DO
!         
      END SUBROUTINE constructFaceCurvesForCapFace
!
!//////////////////////////////////////////////////////////////////////// 
! 
      SUBROUTINE computeCapFacePoints( face, bcurveOrder, curves)  
         USE CurveInterpolantClass
         USE TransfiniteMapClass
         IMPLICIT NONE  
!
!        ---------
!        Arguments
!        ---------
!
         TYPE(Face3D)                     :: face
         INTEGER                          :: bCurveOrder
         TYPE(CurveInterpolant), POINTER  :: curves(:)
!
!        ---------------
!        Local variables
!        ---------------
!
         TYPE(TransfiniteQuadMap) :: mapper
         INTEGER                  :: i, j
!
!        --------------------------------------------------
!        Construct the transfinite map from the four curves
!        --------------------------------------------------
!
               
         mapper = NewTransfiniteQuadMap(boundaryCurves = curves, &
                                        ownership      = MAP_DOESNT_OWN_CURVES)
!
!        ---------------
!        Allocate memory
!        ---------------
!
         ALLOCATE( face % x(3,0:bCurveOrder,0:bCurveOrder) )
         
         DO j = 0, bCurveOrder
            DO i = 0, bCurveOrder
               CALL EvaluateTransfiniteMapAt(this = mapper , &
                                             xi   = chebyPoints(i),&
                                             eta  = chebyPoints(j),&
                                             res  = face % x(:,i,j))
            END DO   
         END DO  

      END SUBROUTINE computeCapFacePoints
!
!//////////////////////////////////////////////////////////////////////// 
! 
      FUNCTION extrudedNodeLocation(baseLocation,delta,pmutation)  RESULT(x)
         IMPLICIT NONE  
         REAL(KIND=RP) :: baseLocation(3), delta
         INTEGER       :: pmutation
         REAL(KIND=RP) :: x(3)
               
         x              = baseLocation
         x(pmutation)   = delta 
      END FUNCTION extrudedNodeLocation
!
!//////////////////////////////////////////////////////////////////////// 
! 
      FUNCTION rotatedNodeLocation(baseLocation,theta,pmutation)  RESULT(x)
         IMPLICIT NONE  
         REAL(KIND=RP) :: baseLocation(3), theta
         INTEGER       :: pmutation
         REAL(KIND=RP) :: x(3)
         REAL(KIND=RP) :: r
               
         x              = baseLocation
         SELECT CASE ( pmutation )
            CASE( 1 ) ! rotation about x-Axis
               r    = baseLocation(2)
               x(2) = r*COS(theta)
               x(3) = r*SIN(theta)
            CASE (2)  ! rotation about y-Axix
               r    = baseLocation(1)
               x(1) = r*COS(theta)
               x(3) = r*SIN(theta)
            CASE (3)  ! rotation about z-Axis
               r    = baseLocation(2)
               x(2) = r*COS(theta)
               x(1) = r*SIN(theta)
            CASE DEFAULT 
         END SELECT 
         
      END FUNCTION rotatedNodeLocation

      END Module SimpleSweepModule 